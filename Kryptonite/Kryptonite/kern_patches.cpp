//
//  kern_patches.cpp
//  Kryptonite
//
//  Created by Mayank Kumar on 6/4/21.
//

#include "kern_patches.hpp"
#include "kern_nvramargs.hpp"
#include "kern_patchapplicator.hpp"
#include "kern_compatibility.hpp"
#include "kern_hooks.hpp"

static PatchApplicator patchApplicator;

void Patches::init() {
    NVRAMArgs::init();
}

void Patches::unblockLegacyThunderbolt(KernelPatcher &patcher, KernelPatcher::KextInfo *kext) {
    if (!NVRAMArgs::isAMD()) {
        return;
    }
    
    KernelPatcher::LookupPatch patch;
    
    if (Compatibility::isOlderKernel()) {
        uint8_t tbType = 0x33;
        if (NVRAMArgs::isThunderbolt1()) {
            tbType = 0x31;
        } else if (NVRAMArgs::isThunderbolt2()) {
            tbType = 0x32;
        }
        const uint8_t find[] = {0x49, 0x4f, 0x54, 0x68, 0x75, 0x6e, 0x64, 0x65, 0x72, 0x62, 0x6f, 0x6c, 0x74, 0x53, 0x77, 0x69, 0x74, 0x63, 0x68, 0x54, 0x79, 0x70, 0x65, 0x33};
        const uint8_t repl[] = {0x49, 0x4f, 0x54, 0x68, 0x75, 0x6e, 0x64, 0x65, 0x72, 0x62, 0x6f, 0x6c, 0x74, 0x53, 0x77, 0x69, 0x74, 0x63, 0x68, 0x54, 0x79, 0x70, 0x65, tbType};
        patch = {kext, find, repl, sizeof(find), 1};
    } else {
        const uint8_t find[] = {0xf8, 0x03, 0x0f, 0x82, 0x78, 0xff, 0xff, 0xff, 0x49, 0x8b, 0x06, 0xc6, 0x80, 0x78, 0x01, 0x00};
        const uint8_t repl[] = {0xf8, 0x00, 0x0f, 0x82, 0x78, 0xff, 0xff, 0xff, 0x49, 0x8b, 0x06, 0xc6, 0x80, 0x78, 0x01, 0x00};
        patch = {kext, find, repl, sizeof(find), 1};
    }
    patchApplicator.applyLookupPatch(patcher, &patch);
}

void Patches::bypassPCITunnelled(KernelPatcher &patcher, KernelPatcher::KextInfo *kext) {
    if (!NVRAMArgs::isNVDA()) {
        return;
    }
    
    const uint8_t find[] = {0x49, 0x4f, 0x50, 0x43, 0x49, 0x54, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6c, 0x65, 0x64};
    const uint8_t repl[] = {0x49, 0x4f, 0x50, 0x43, 0x49, 0x54, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x6c, 0x65, 0x71};
    KernelPatcher::LookupPatch patch = {kext, find, repl, sizeof(find), 1};
    patchApplicator.applyLookupPatch(patcher, &patch);
}

void Patches::bypassIOPCITunnelCompatible(KernelPatcher &patcher, KernelPatcher::KextInfo *kext) {
    KernelPatcher::LookupPatch patch;
    switch (getKernelVersion()) {
        case KernelVersion::HighSierra:
        case KernelVersion::Mojave: {
            const uint8_t find[] = {0xff, 0x90, 0xa8, 0x02, 0x00, 0x00, 0x48, 0x85, 0xc0, 0x0f, 0x84, 0xbc, 0x00, 0x00, 0x00};
            const uint8_t repl[] = {0xff, 0x90, 0xa8, 0x02, 0x00, 0x00, 0x48, 0x85, 0xc0, 0x48, 0xe9, 0xbc, 0x00, 0x00, 0x00};
            patch = {kext, find, repl, sizeof(find), 1};
            break;
        }
            
        default: {
            const uint8_t find[] = {0xff, 0x90, 0xa8, 0x02, 0x00, 0x00, 0x48, 0x85, 0xc0, 0x0f, 0x84, 0xb9, 0x00, 0x00, 0x00};
            const uint8_t repl[] = {0xff, 0x90, 0xa8, 0x02, 0x00, 0x00, 0x48, 0x85, 0xc0, 0x48, 0xe9, 0xb9, 0x00, 0x00, 0x00};
            patch = {kext, find, repl, sizeof(find), 1};
            break;
        }
    }
    patchApplicator.applyLookupPatch(patcher, &patch);
}

void Patches::updateMuxControlNVRAMVar(KernelPatcher &patcher, KernelPatcher::KextInfo *kext) {
    const uint8_t find[] = {0x46, 0x41, 0x34, 0x43, 0x45, 0x32, 0x38, 0x44, 0x2d, 0x42, 0x36, 0x32, 0x46, 0x2d,
        0x34, 0x43, 0x39, 0x39, 0x2d, 0x39, 0x43, 0x43, 0x33, 0x2d, 0x36, 0x38, 0x31,
        0x35, 0x36, 0x38, 0x36, 0x45, 0x33, 0x30, 0x46, 0x39, 0x3a, 0x67, 0x70, 0x75,
        0x2d, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x2d, 0x70, 0x72, 0x65, 0x66, 0x73};
    const uint8_t repl[] = {0x46, 0x41, 0x34, 0x43, 0x45, 0x32, 0x38, 0x44, 0x2d, 0x42, 0x36, 0x32, 0x46, 0x2d,
        0x34, 0x43, 0x39, 0x39, 0x2d, 0x39, 0x43, 0x43, 0x33, 0x2d, 0x36, 0x38, 0x31,
        0x35, 0x36, 0x38, 0x36, 0x45, 0x33, 0x30, 0x46, 0x39, 0x3a, 0x67, 0x70, 0x75,
        0x2d, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x2d, 0x70, 0x72, 0x65, 0x66, 0x71};
    KernelPatcher::LookupPatch patch = {kext, find, repl, sizeof(find), 1};
    patchApplicator.applyLookupPatch(patcher, &patch);
}

void Patches::routeThunderboltEnumeration(KernelPatcher &patcher, size_t *index, mach_vm_address_t *address, size_t *size) {
    mach_vm_address_t orgSkipEnumerationCallback {0};
    KernelPatcher::RouteRequest request("__ZN24IOThunderboltSwitchType321shouldSkipEnumerationEv", FunctionHooks::thunderboltShouldSkipEnumeration, {orgSkipEnumerationCallback});
    patchApplicator.applyRoutingPatch(*index, patcher, &request, *address, *size);
}
